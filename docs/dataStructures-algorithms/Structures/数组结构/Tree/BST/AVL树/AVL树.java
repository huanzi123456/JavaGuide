package Tree.BST.AVL树;

/**
 *二叉搜索树:复杂度分析
 *  O(h) == O(logN)   链表:的
 *  添加:  破坏平衡
 *  搜索:
 *  删除:  退化成链表
 *平衡:
 *      当节点数量固定的时,左右子树的高度越接近,这棵树二叉树就越平衡
 *      最理想的平衡,完全二叉树
 *      改进二叉树: 节点的添加,删除操作之后,让二叉搜索树恢复平衡(减小树的高度)
 *      用最小的时间复杂度,达到适当平衡,这样的树称为,平衡二叉搜索树
 *      Balanced BST
 *          二叉搜索树: 添加的自平衡称为平衡二叉树
 *          avl树:
 *              平衡因子:某结点的左 - 右子树的高度差!
 *              每个节点的平衡因子只可能(1,0,-1) 超过1,称之为失衡
 *              搜素,添加,删除的时间复杂度为O(logN)
 *
 *              继承二叉搜索树:
 *
 *              添加导致的失衡:
 *                  由于是继承二叉搜索树,添加方法之后调用二叉搜索树的 额外方法!
 *                  avl树重写方法,循环找父节点直到根节点,
 *                  判断平衡:
 *                      重看,137
 *                      139是介绍网站
 *                      140是左旋转: 重看
 *                      141是右旋转: 重看
 *                      143实例旋转
 *                      144
 *              删除导致的平衡
 *                  同添加之后的方法一样,
 *                      二叉搜索树:删除度为2的节点,
 *                                 删除度为1的节点,
 *                  参考删除方法:
 *             总结:
 *              添加:   会导致所有祖先节点,都失衡!
 *                     只要让高度最低的失衡节点,恢复平衡,整体树恢复平衡调整(O(1))
 *              删除:   只可能会导致父节点失衡,
 *                      让父节点恢复平衡后,会导致更高的祖先节点[最多需要O(logN)调整]
 *              149补充
 *
 *
 *
 *
 *
 *          红黑树:
 *              (java   TreeMap,TreeSet,HashMap,HashSet)
 *              Linux 进程调度
 *              Nginx timer管理
 *         自平衡的二叉树:
 *              添加导致的平衡:最坏的情况可能导致所有的祖先节点失衡
 *              父节点,非祖先节点都不可能失衡!
 *
 *              知道是否平衡需要有一个高度属性(计算左右子树的高度差):
 *
 */
public class AVL树 {

}
